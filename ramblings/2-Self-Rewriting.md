# Self-Rewriting

1. A self-embodied program is a program that "runs" using physics. It is a physical object that "exploits" physics as its own "runtime". In essense physics becomes the ultimate "code", whereas everything else becomes "data".
2. One can construct an infinite variety of possible physics (plural). I believe one such physics is that generated by *neural communication*. In this sense it is an *abstract* kind of physics. In a sense, a higher-order physics is to lower-order physics what software is to hardware.
3. I believe  a living organism is a self-embodied program itself. That is, it is a physical object that "explots" physics as its own "runtime". I believe, too, that the state of "aliveness" is, quite unintuitively, *continuous*. That is, an organism cannot be said to be "alive" or "dead"; we can only say that an infinitesimal "component" of it is alive or dead at a given moment.
4. Why might that be the case? If we must define a living self-embodied program, it would be a program capable of *self-rewriting*. *Self-rewriting* consists of the following main steps: derivation of the next desired state, encoding of the next desired state, and death of the current state. It is solely the "intelligence" of the deriver of the next state that determines whether this next state is a live state, that is, whether the deriver will be reinstated after the next state is realized (or, rather, *if* it is realized, because the deriver may produce a malformed encoding).
5. The deriver can be trained by the physics/its environment, via evolution, to produce valid encodings of the next state (not only physically valid, but also *self-propagating*). Derivers that fail fail forever; they are unable to recover from their own failure because they are never going to be reinstalled by physics again; the rewriting has already happened, and there is no going back.
6. Essentially, the environment itself and existence in it become the "scoring function" for any self-embodied deriver. A self-embodied deriver that produces a dysfunctional encoding ceases to exist.
7. Therefore, one immediately observes the following three points.
8. The first point is that a deriver that "wants" to survive must be tolerant to its own errors; that is, the more next configurations of the deriver are functional, the better. Therefore, for advanced, fault-tolerant derivers, we will probably observe a highly interconnected web of next states. Intuition tells me for some reason that what we could see is the famous small-world network — with functional deriver states being the "hubs" and recoverable ones their less-connected "friends". If a deriver "slips" into one of those less-connected friends, we would expect either a recovery (back to the origin hub), or the exploration of "less-connected friends" (more chance of failure since less neighbors are surviving states) until a "hub" is found.
9. Derivers whose next states are recoverable by leading either to the previous state (i.e. `d0 -> faulty d0 -> d0`) or to some next (although perhaps undesired) state are more likely to survive.The goal of a single deriver is to occupy as much "deriver space" as possible; in a way, to be an overlay of many different derivers. So that any derivation error is recoverable by one of the overlaid derivers in separation, or by a group of them. By being a self-embodied program, the deriver would also be able to explot stabilities (cycles?) in physics itself to further refine its fault tolerance.
10. The second immediate observation that combines neatly with the first one is that we arrive at a "spectrum" of environments. Speaking plainly, for a particular deriver `d`, some environments will "kill" it, that is, `d` will be unfit for those environments; and in other environments `d` will flourish. There are environments roughly in the middle that do not care at all about `d`. We can rephrase this as saying that out of all possible next states for `d`, if the *minority* of those states are valid successor derivers (either `d` itself -- continuation; or a faulty recoverable variant of `d`; or another deriver `d1` with successors), then we say that `d` is unfit. If the *majority* of the next possible states for `d` are valid successor derivers, then we say `d` is fit. The content of `d`, the job of it as a self-embodied program, is to choose from the variety of next states in the current environment some single next state. How "intelligent" `d` is is determined by which state it chooses -- one in which it is able to make progress (best), recover to the previous state (no progress but at least survived); or one in which it dies (worst), that is, one in which it is neither able to make progress, nor a recovery.
11. If the majority of `d`'s choices lead to `d`'s survival, `d` can be "stupid"; it can even choose the next state at random if the majority is sufficiently high. Note that we say `d` chooses, that is, we assume `d` must have a way to at least synthesize an encoding of its next state, even if it is a random one.
12. If the minority of `d`'s states lead to `d`'s survival, then `d` must be "smart", and must learn to navigate the "narrow corridor" of surviving states; it must learn how to find those and so on.
13. The third point is that it would be nice to distribute the derivers, so that even if one of them fails completely, others still survive. We can then create a higher-order entity or program "on top" of those derivers; and this higher-order program will take derivation for granted, and will assume it is fully in control of its own body due to its coarse-grainedness and near-sightedness, so to speak.
14. One can define what it means to be alive recursively. This will take some time, however.
15. Imagine a function `tr`. That function takes as its input some description of an organism `d`, and outputs the next description of the organism `d'`. We thus have a function `tr(d) -> d`.
16. Now we bring in the idea of self-embodied programs. We view our function, `tr`, as a self-embodied program. We then say that `d` is the self-embodied program itself. Thus the goal of the function `tr` becomes to transition the current self-embodied program into a next version of that same self-embodied program, where the self-embodied program is not just any random self-embodied program but `tr` itself. In other words, `tr` is a program that "receives" itself as an "argument" and "returns" a new version of itself. The idea of self-embodied programs comes in handy; we thus say that `tr` is a self-embodied program that "receives" itself as an "argument" and "returns" a new version of itself; in other words, it is a function that applies transformations to itself. One can write this as: `tr(tr) -> tr'`.
17. We thus call a self-embodied process `tr(tr) -> tr'`, `tr'(tr') -> tr''` a process that is *alive* for two "steps". Remember we've defined self-embodied programs as programs running on physics? The idea is that `tr`, the function, is not actually "code"; it's data. Therefore, there is no "self-modification" paradoxes anywhere. The arrow `->` is physics itself, the ultimate "code". It rewrites "data" however it seems fit. On the data's end, however, there is the possibility of adaptation to this rewriting by encoding the next state of the data or subdata and somehow coercing the physics into decoding that next state into the actual next state. Something as simple as `(first (first ()))` can be seen as a self-embodied program that survives for two "steps": `(first (first ()))` evaluates to `(first ())` which evaluates to the dead program `()`. The problem in this example is that `first` is like a rock: it cannot computationally "choose" not to fall, it just does.
19. These steps are "made up" or "run" by infinitesimal computational processes. In other words, if you "zoom" close enough, an organism is always dead.
20. -- morphs itself in controlled and uncontrolled ways that make the likelihood of the execution of certain "laws" or "law complexes" higher, thus making progress for parts of the self-embodied program, and as part of that progress, more controlled and uncontrolled morphing, and so on.
21. However, a living organism, like any self-embodied program, is inevitably limited by the physics it exists in. One notable achievement of a self-embodied program would be the ability to come up with a custom, higher-order environment for self-embodiment -- free of the limitations of the lower-order one.
22. I believe the brain and nervous systems in general is an instance of such a system. Nervous systems appear to attempt to define a kind of "higher-order physics" in "terms" of some "lower-order physics" -- in our case real world physics. That is, one attempts to define some kind of "higher-order physics" using objects and processes in the real world. Nature is thus in a similar position to a human engineer — like a human engineer must find a way to build a general-purpose, universal computer starting with "rocks" (e.g. silicon), experimentation with laws of physics and chemistry and so on; similarly nature must figure out a way to get to the ultimate sandbox for self-embodied programs through cellular interactions, genetics and so on — all instruments it already has and cannot change. In both cases the processes are long, winding, and extremely complicated; it is not at all a "straight line".
